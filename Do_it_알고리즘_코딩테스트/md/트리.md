## 트리

트리는 노드와 에지로 연결된 그래프의 특수한 형태  
= 그래프의 표현으로 트리를 표현할 수 있다!

### 트리의 특징
- 순환 구조를 지니고 있지 않고, 1개의 루트 노드가 존재
- 루트 노드를 제외한 노드는 단 1개의 부모 노드를 갖는다
- 트리의 부분 트리 역시 트리의 모든 특징을 따른다

⭐ 트리에서 임의의 두 노드를 이어주는 경로는 유일하다

### 트리의 핵심 이론
![img.png](../img/트리의구성요소.png)  
- 노드 : 데이터의 index와 value를 표현하는 요소  
- 에지 : 노드와 노드의 연결 관계를 나타내는 선  
- 루트 노드 : 트리에서 가장 상위에 존재하는 노드  
- 부모 노드 : 두 노드 사이의 관계에서 상위 노드에 해당하는 노드  
- 자식 노드 : 두 노드 사이의 관계에서 하위 노드에 해당하는 노드  
- 리프 노드 : 트리에서 가장 하위에 존재하는 노드 (자식 노드가 없음)  
- 서브 트리 : 전체 트리에 속한 작은 트리  

### 코딩테스트 팁 !!
```text
코딩테스트에서 tree

1. 그래프로 푸는 tree
(i) 노드와 에지를 인접 리스트로 표현
(ii) DFS, BFS

2. ⭐ tree 만을 위한 문제
-> 이진 트리 & 세그먼트 트리(index tree) & LCA(최소공통조상)

⭐ 세그먼트 트리
⭐ LCA
=> 1차원 배열로 tree 표현
```

### ⭐ 이진 트리
**이진 트리는 각 노드의 자식 노드의 개수가 2 이하로 구성된 트리**  

#### 이진 트리의 핵심 이론
1. 이진 트리 종류  
![img.png](../img/이진트리종류.png)  
- 편향 이진 트리 : 노드들이 한쪽으로 편향  
  → 탐색 속도 저하, 공간 낭비
- 포화 이진 트리 : 트리 높이가 모두 일정하며 리프 노드가 꽉 참
- 완전 이진 트리 : 마지막 레벨을 제외하고 노드들이 채워져 있음 (마지막 레벨은 왼쪽부터 채워짐)  
  → 일반적인 코딩 테스트 트리 (LCA, index tree)

2. 이진 트리 순차 표현  
'**배열**' : 가장 직관적이면서 편리한 트리 자료구조  

![img.png](../img/이진트리순차표현.png)  
⭐ ![img.png](../img/트리노드배열인덱스.png)  
→ 세그먼트 트리, LCA 알고리즘에서 기본이 되는 연산

---

#### 1991 트리 순회하기

```text
⭐ A 가 항상 루트 노드
💫 재귀 함수

특별한 아이디어를 떠올릴 필요 없이 문제가 요구하는 자료구조 형태만 충실히 구현하는 문제
주어진 입력값을 트리 형태의 자료구조에 적절하게 저장하고, 탐색을 수행하는 로직 구현

🔧 2차원 배열로 풀어보자
1. 2차원 배열에 트리 데이터 저장
2. 전위 순회 함수 구현 : 현재 → 왼쪽 → 오른쪽
3. 2와 같은 방법으로 중위 순회, 후위 순회 함수 구현
```

![img.png](../img/이진트리전위순회.png)  
⬆️ 전위 순회

```text
#include <iostream>
using namespace std;

static int n;
static int tree[26][2]; // 알파벳 26개

void preOrder(int now);
void inOrder(int now);
void postOrder(int now);

int main() {
    // 시간 복잡도 해결
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    // 노드 개수 입력
    cin >> n;
    
    for (int i = 0; i < n; i++) {
        char node_char, left, right;
        cin >> node_char >> left >> right;
        int node = node_char - 'A'; // A 가 들어오면 node 값은 0 => 인덱스 역할
        
        if (left == '.') { // 자식 노드 없을 때 -1 입력
            tree[node][0] = -1;
        } else {
            tree[node][0] = left - 'A';
        }
        
        if (right == '.') { // 자식 노드 없을 때 -1 입력
            tree[node][1] = -1;
        } else {
            tree[node][1] = right - 'A';
        }
    }
    
    preOrder(0);
    cout << "\n";
    inOrder(0);
    cout << "\n";
    postOrder(0);
    cout << "\n";
}

void preOrder(int now) { // 현재 → 왼쪽 → 오른쪽
    if (now == -1) return;
    cout << (char)(now + 'A'); // 현재 노드 출력 - 출력은 다시 문자형으로 (인덱스로 저장되어 있었음)
    preOrder(tree[now][0]); // 왼쪽 노드 탐색
    preOrder(tree[now][1]); // 오른쪽 노드 탐색
}
void inOrder(int now) { // 왼쪽 → 현재 → 오른쪽
    if (now == -1) return;
    inOrder(tree[now][0]); // 왼쪽 노드 탐색
    cout << (char)(now + 'A'); // 현재 노드 출력 - 출력은 다시 문자형으로 (인덱스로 저장되어 있었음)
    inOrder(tree[now][1]); // 오른쪽 노드 탐색
}
void postOrder(int now) { // 왼쪽 → 오른쪽 → 현재
    if (now == -1) return;
    postOrder(tree[now][0]); // 왼쪽 노드 탐색
    postOrder(tree[now][1]); // 오른쪽 노드 탐색
    cout << (char)(now + 'A'); // 현재 노드 출력 - 출력은 다시 문자형으로 (인덱스로 저장되어 있었음)
}
```