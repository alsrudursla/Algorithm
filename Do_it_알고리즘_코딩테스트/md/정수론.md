## 정수론

### 소수 구하기

수학적인 문제에서 빈번하게 출제

- 소수 = 1과 자기 자신 외에 약수가 존재하지 않는 수
- 대표적인 판별법 : 에라토스테네스의 체
- 에라토스테네스의 체 시간 복잡도 : O(Nlog(logN))

#### 에라토스테네스의 체의 원리
1. 구하고자 하는 소수의 범위만큼 1차원 배열 생성
2. 2부터 시작하고 현재 숫자가 지워지지 않을 때는 현재 선택된 숫자의 배수에 해당하는 수를 배열에서 끝까지 탐색하면서 지운다  
    이때 처음으로 선택된 숫자는 지우지 않는다 (소수)
3. 배열의 끝까지 2번 반복 후, 배열에서 남아 있는 모든 수 출력

<br>

### 유클리드 호제법




---

#### 1929

```text
1. 크기가 N+1 인 배열을 선언한 후, 값은 각각의 인덱스값으로 채운다 (0 포함)
2. 1은 소수가 아니므로 삭제
3. 2부터 N 의 제곱근까지 값을 탐색 -> 값이 인덱스값이면 그대로 두고, 그 값의 배수를 탐색해 0으로 변경
4. 배열에 남아 있는 수 중에서 M 이상 N 이하의 수를 모두 출력

* N의 제곱근까지만 탐색하기
N 이 axb 라고 가정했을 때, a와 b 모두 N 의 제곱근보다 클 수 없다.
따라서 N 의 제곱근까지만 확인해도 전체 범위의 소수를 판별할 수 있다.
만약 16의 범위까지 소수를 구할 때 16=4x4로 이뤄지면 16보다 작은 숫자는 항상 4보다 작은 약수를 갖게 된다는 뜻이다.
따라서 4까지만 확인하고 소수 판별을 진행하면 된다.
```
```java
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int M = sc.nextInt();
        int N = sc.nextInt();
        int []A = new int[N+1];
        for (int i = 1; i <= N; i++) {
            A[i] = i;
        }
        
        for (int i = 2; i <= Math.sqrt(N); i++) {
            if (A[i] == 0) continue;
            for (int j = i+i; j <= N; j = j+i) {
                A[j] = 0;
            }
        }
        
        for (int i = M; i <= N; i++) {
            if (A[i] != 0) {
                System.out.println(A[i]);
            }
        }
    }
}
```